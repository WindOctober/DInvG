2

- Initialize_before_Parser doing...
/----------------------------- 
| Adjacency Matrix for Location and Transition: 
----------------------------- 
| Input: 2 transitions
----------------------------- 
| [#] is transition_index
| Location_0: [ 0 ]->Location_0;  [ 1 ]->le;  
| le: []->Location_0;  []->le;  
----------------------------- 
| Output: 2 transitions
\----------------------------- 

> > > Location::compute_dual_constraints(), Location: Location_0's Initialization
- Initial-Value is not empty: 
  C - D = 0, B = 1, A = 1
< < < Location::compute_dual_constraints(), Location: Location_0's Initialization

> > > Location::compute_dual_constraints(), Location: le's Initialization
- Initial-Value is not empty: 
  true
< < < ( !polyset ) in Location::le

> > > (intra transition) In compute_consecution_constraints(), TransitionRelation : Transition_0_0
Current transition has poly as follows: 
  E = 1, C - G = 1, C >= 2
  Compute this transition: 1
  pushing back clump with 1 Polyhedra (in falsepath)...
< < < Intra-Transition::Transition_0_0 prepare to push back clump with 1 Polyhedra

> > > (inter transition) In compute_consecution_01(), TransitionRelation : Exit_Transition_from_0_index_0
Current transition has poly as follows: 
  G = 0, E = 1, C = 1
  Compute this transition: 0
< < < Inter-Transition::Exit_Transition_from_0_index_0 pushing back clump with 0 Polyhedra...done
> > > Location::Location_0 already has clump with 1 Polyhedra...
> > > Location::Location_0 altogether pushing back clump with 2 Polyhedra...done
> > > Location::le already has clump with 0 Polyhedra...
> > > Location::le altogether pushing back clump with 1 Polyhedra...done

/ Start to solve Location Location_0
/ Using target_prior2
/ Generate Sequences
> > > Tree::sequences generation()
> > > Tree::two_per_group()

From hb:1 To lb:0
> > > Tree::dfs_sub_sequences_traverse()
( Weaved Prune Tree, current length is 2
( 1  ⋁  [0] 1  --  b: 0 --  Location_Intra:: Location_0
( 0  ⋁  [0]    --  b: 0 --  Location_Intra:: le
( Weaved Prune Tree, current length is 2
( 1  ⋁   0 [1] --  b: 0 --  Location_Intra:: Location_0
( 0  ⋁  [0]    --  b: 0 --  Location_Intra:: le
Above part, the 1th poly is erased by next poly in back-prune
This sub_sequences invd_vp has weaved:1
< < < Tree::dfs_sub_sequences_traverse()
sub_sequences.size()/capacity():1/1
This PRE_LOC has banged:1
< < < Tree::two_per_group()
< < < Tree::sequences generation()
- ( !init_poly_flag ) in Location::le

/ Start to solve Location Location_0
/ Using target_prior2
/ Read(Traverse) Sequences
> > > Tree::dfs_sequences_traverse()

sequence:10
/-----------------------------
( Weaved Prune Tree, current length is 2
( 1  ⋁   0 [1] --  b: 0 --  Location:: Location_0
( 0  ⋁  [0]    --  b: 0 --  Location:: le
For location: Location_0
「 l: 0, vars_num: 4, dual_num: 10 」
> > > Project_by_Kohler(), doing...
< < < Project_by_Kohler(), done!

- Have Collected 1 invariant(s)
- The collect_invariants Time Taken (0.01s) = 0
\-----------------------------
< < < Tree::dfs_sequences_traverse()
- ( !init_poly_flag ) in Location::le

> > > compute_invariants_by_propagation_with_farkas()
- YES! Initial Location:: Location_0
' 1 location [ 0 ] remained in initial_lid

> > > invgen_need_working()
* all_ppg_flag: 1
! invgen is over !
< < < invgen_need_working()
/------------------------------(Propagation to Exit-Location)
= Location le is being Propagated:
= From Location invariant Location_0
  A = 1
= Through Transition relation Exit_Transition_from_0_index_0: 
  G = 0, E = 1, C = 1
= Propagated Location Invariant le
  true
* After intersection 
  G = 0, E = 1, C = 1, A = 1
* Propagated Invariant at le
  C = 0, A = 1
\------------------------------(Propagation to Exit-Location)
< < < compute_invariants_by_propagation_with_farkas()
----------------------------- 
| The Locations read in are: 
----------------------------- 

Location: Location_0
# of variables: 4
「 l: 0, vars_num: 4, dual_num: 10 」
Initial Condition: [[ 
| 
├ 1 * r1 -1 * r1_initvariable_avoid_var_conflict_october  = 0 
├ 1 * s1_initvariable_avoid_var_conflict_october -1 = 0 
├ 1 * s1 -1 = 0 
| 
]]
Invariant: [[ 
| 
├ 1 * s1 -1 = 0 
| 
]]

Location: le
# of variables: 4
「 l: 5, vars_num: 4, dual_num: 10 」
[ no initial condition set]
Disjunctive Invariant: [[ 
  
1 * r1  = 0 
1 * s1 -1 = 0 
  
]]
[info] Using default compilation options.


[print statement info]
DeclStmt


[print statement info]
WhileStmt


[print statement info]
BinaryOperator
binary operator: DeclRefExpr = IntegerLiteral 

[print statement info]
UnaryOperator
unary operator: DeclRefExpr -- 

[Print DNF Information]
DNF disjunctive branch 0 and its size is:3
	[DNF Number 0 is:]
	r1 > 0
	[DNF Number 1 is:]
	r1 = r1 - 1
	[DNF Number 2 is:]
	s1 = 1
DNF disjunctive clause 0 is printed.
[Print Init_DNF Information]
Init_DNF disjunctive branch 0 and its size is:0
Init_DNF disjunctive clause 0 is printed.

[Print Init Variables Information]
Vars Count 0 and its member size is: 2
	[Variable Number 0 is:]
	 Variable Name is:r1
	 Variable Value is:No Initialized.
	 Variable InLoop is: 0
	 Variable Type is: int
	[Variable Number 1 is:]
	 Variable Name is:s1
	 Variable Value is:1
	 Variable InLoop is: 0
	 Variable Type is: int


[Print Variables Information]
Vars Count 0 and its member size is: 1
	[Variable Number 0 is:]
	 Variable Name is:s1
	 Variable Value is:1
	 Variable InLoop is: 1
	 Variable Type is: int

[check_guard info] The Expr r1 = r1_initvariable_avoid_var_conflict_october is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr s1_initvariable_avoid_var_conflict_october = 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr s1 = s1_initvariable_avoid_var_conflict_october is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr r1 > 0 is guard

[check_guard info] The Expr r1 = r1 - 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr s1 = 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr r1 > 0 is guard

[check_guard info] The Expr r1 > 0 is guard

[check_guard info] The Expr r1 = r1 - 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr s1 = 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr r1 > 0 is guard

[check_guard info] The Expr r1 = r1 - 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr s1 = 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr r1 > 0 is guard

[check_guard info] The Expr r1 = r1 - 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr s1 = 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr r1 <= 0 is guard


[print statement info]
ParenExpr
paren expression: BinaryOperator 

[print statement info]
DeclStmt


[print statement info]
WhileStmt


[print statement info]
BinaryOperator
binary operator: DeclRefExpr = IntegerLiteral 

[print statement info]
UnaryOperator
unary operator: DeclRefExpr -- 

[Print DNF Information]
DNF disjunctive branch 0 and its size is:3
	[DNF Number 0 is:]
	r2 > 0
	[DNF Number 1 is:]
	r2 = r2 - 1
	[DNF Number 2 is:]
	s2 = 1
DNF disjunctive clause 0 is printed.
[Print Init_DNF Information]
Init_DNF disjunctive branch 0 and its size is:0
Init_DNF disjunctive clause 0 is printed.

[Print Init Variables Information]
Vars Count 0 and its member size is: 2
	[Variable Number 0 is:]
	 Variable Name is:r2
	 Variable Value is:No Initialized.
	 Variable InLoop is: 0
	 Variable Type is: int
	[Variable Number 1 is:]
	 Variable Name is:s2
	 Variable Value is:1
	 Variable InLoop is: 0
	 Variable Type is: int


[Print Variables Information]
Vars Count 0 and its member size is: 1
	[Variable Number 0 is:]
	 Variable Name is:s2
	 Variable Value is:1
	 Variable InLoop is: 1
	 Variable Type is: int

[check_guard info] The Expr r2 = r2_initvariable_avoid_var_conflict_october is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr s2_initvariable_avoid_var_conflict_october = 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr s2 = s2_initvariable_avoid_var_conflict_october is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr r2 > 0 is guard

[check_guard info] The Expr r2 2

- Initialize_before_Parser doing...
/----------------------------- 
| Adjacency Matrix for Location and Transition: 
----------------------------- 
| Input: 2 transitions
----------------------------- 
| [#] is transition_index
| Location_0: [ 0 ]->Location_0;  [ 1 ]->le;  
| le: []->Location_0;  []->le;  
----------------------------- 
| Output: 2 transitions
\----------------------------- 

> > > Location::compute_dual_constraints(), Location: Location_0's Initialization
- Initial-Value is not empty: 
  C - D = 0, B = 1, A = 1
< < < Location::compute_dual_constraints(), Location: Location_0's Initialization

> > > Location::compute_dual_constraints(), Location: le's Initialization
- Initial-Value is not empty: 
  true
< < < ( !polyset ) in Location::le

> > > (intra transition) In compute_consecution_constraints(), TransitionRelation : Transition_0_0
Current transition has poly as follows: 
  E = 1, C - G = 1, C >= 2
  Compute this transition: 1
  pushing back clump with 1 Polyhedra (in falsepath)...
< < < Intra-Transition::Transition_0_0 prepare to push back clump with 1 Polyhedra

> > > (inter transition) In compute_consecution_01(), TransitionRelation : Exit_Transition_from_0_index_0
Current transition has poly as follows: 
  G = 0, E = 1, C = 1
  Compute this transition: 0
< < < Inter-Transition::Exit_Transition_from_0_index_0 pushing back clump with 0 Polyhedra...done
> > > Location::Location_0 already has clump with 1 Polyhedra...
> > > Location::Location_0 altogether pushing back clump with 2 Polyhedra...done
> > > Location::le already has clump with 0 Polyhedra...
> > > Location::le altogether pushing back clump with 1 Polyhedra...done

/ Start to solve Location Location_0
/ Using target_prior2
/ Generate Sequences
> > > Tree::sequences generation()
> > > Tree::two_per_group()

From hb:1 To lb:0
> > > Tree::dfs_sub_sequences_traverse()
( Weaved Prune Tree, current length is 2
( 1  ⋁  [0] 1  --  b: 0 --  Location_Intra:: Location_0
( 0  ⋁  [0]    --  b: 0 --  Location_Intra:: le
( Weaved Prune Tree, current length is 2
( 1  ⋁   0 [1] --  b: 0 --  Location_Intra:: Location_0
( 0  ⋁  [0]    --  b: 0 --  Location_Intra:: le
Above part, the 1th poly is erased by next poly in back-prune
This sub_sequences invd_vp has weaved:1
< < < Tree::dfs_sub_sequences_traverse()
sub_sequences.size()/capacity():1/1
This PRE_LOC has banged:1
< < < Tree::two_per_group()
< < < Tree::sequences generation()
- ( !init_poly_flag ) in Location::le

/ Start to solve Location Location_0
/ Using target_prior2
/ Read(Traverse) Sequences
> > > Tree::dfs_sequences_traverse()

sequence:10
/-----------------------------
( Weaved Prune Tree, current length is 2
( 1  ⋁   0 [1] --  b: 0 --  Location:: Location_0
( 0  ⋁  [0]    --  b: 0 --  Location:: le
For location: Location_0
「 l: 0, vars_num: 4, dual_num: 10 」
> > > Project_by_Kohler(), doing...
< < < Project_by_Kohler(), done!

- Have Collected 1 invariant(s)
- The collect_invariants Time Taken (0.01s) = 0
\-----------------------------
< < < Tree::dfs_sequences_traverse()
- ( !init_poly_flag ) in Location::le

> > > compute_invariants_by_propagation_with_farkas()
- YES! Initial Location:: Location_0
' 1 location [ 0 ] remained in initial_lid

> > > invgen_need_working()
* all_ppg_flag: 1
! invgen is over !
< < < invgen_need_working()
/------------------------------(Propagation to Exit-Location)
= Location le is being Propagated:
= From Location invariant Location_0
  A = 1
= Through Transition relation Exit_Transition_from_0_index_0: 
  G = 0, E = 1, C = 1
= Propagated Location Invariant le
  true
* After intersection 
  G = 0, E = 1, C = 1, A = 1
* Propagated Invariant at le
  C = 0, A = 1
\------------------------------(Propagation to Exit-Location)
< < < compute_invariants_by_propagation_with_farkas()
----------------------------- 
| The Locations read in are: 
----------------------------- 

Location: Location_0
# of variables: 4
「 l: 0, vars_num: 4, dual_num: 10 」
Initial Condition: [[ 
| 
├ 1 * r2 -1 * r2_initvariable_avoid_var_conflict_october  = 0 
├ 1 * s2_initvariable_avoid_var_conflict_october -1 = 0 
├ 1 * s2 -1 = 0 
| 
]]
Invariant: [[ 
| 
├ 1 * s2 -1 = 0 
| 
]]

Location: le
# of variables: 4
「 l: 5, vars_num: 4, dual_num: 10 」
[ no initial condition set]
Disjunctive Invariant: [[ 
  
1 * r2  = 0 
1 * s2 -1 = 0 
  
]]
= r2 - 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr s2 = 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr r2 > 0 is guard

[check_guard info] The Expr r2 > 0 is guard

[check_guard info] The Expr r2 = r2 - 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr s2 = 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr r2 > 0 is guard

[check_guard info] The Expr r2 = r2 - 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr s2 = 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr r2 > 0 is guard

[check_guard info] The Expr r2 = r2 - 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr s2 = 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr r2 <= 0 is guard


[print statement info]
ParenExpr
paren expression: BinaryOperator 

[print statement info]
ReturnStmt
