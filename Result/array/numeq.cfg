2

- Initialize_before_Parser doing...
/----------------------------- 
| Adjacency Matrix for Location and Transition: 
----------------------------- 
| Input: 2 transitions
----------------------------- 
| [#] is transition_index
| Location_0: [ 0 ]->Location_0;  [ 1 ]->le;  
| le: []->Location_0;  []->le;  
----------------------------- 
| Output: 2 transitions
\----------------------------- 

> > > Location::compute_dual_constraints(), Location: Location_0's Initialization
- Initial-Value is not empty: 
  D = 0, C = 0
< < < Location::compute_dual_constraints(), Location: Location_0's Initialization

> > > Location::compute_dual_constraints(), Location: le's Initialization
- Initial-Value is not empty: 
  true
< < < ( !polyset ) in Location::le

> > > (intra transition) In compute_consecution_constraints(), TransitionRelation : Transition_0_0
Current transition has poly as follows: 
  C - G = -1, -C + E >= 2, A - C >= 1
  Compute this transition: 1
  pushing back clump with 1 Polyhedra (in falsepath)...
< < < Intra-Transition::Transition_0_0 prepare to push back clump with 1 Polyhedra

> > > (inter transition) In compute_consecution_01(), TransitionRelation : Exit_Transition_from_0_index_0
Current transition has poly as follows: 
  C - G = -1, C - E >= -1, A - C >= 1
  Compute this transition: 0
< < < Inter-Transition::Exit_Transition_from_0_index_0 pushing back clump with 0 Polyhedra...done
> > > Location::Location_0 already has clump with 1 Polyhedra...
Back Prune: new contains one of this
> > > Location::Location_0 altogether pushing back clump with 2 Polyhedra...done
> > > Location::le already has clump with 0 Polyhedra...
> > > Location::le altogether pushing back clump with 1 Polyhedra...done

/ Start to solve Location Location_0
/ Using target_prior2
/ Generate Sequences
> > > Tree::sequences generation()
> > > Tree::two_per_group()

From hb:1 To lb:0
> > > Tree::dfs_sub_sequences_traverse()
( Weaved Prune Tree, current length is 2
( 1  ⋁  [0] 1  --  b: 0 --  Location_Intra:: Location_0
( 0  ⋁  [0]    --  b: 0 --  Location_Intra:: le
( Weaved Prune Tree, current length is 2
( 1  ⋁   0 [1] --  b: 0 --  Location_Intra:: Location_0
( 0  ⋁  [0]    --  b: 0 --  Location_Intra:: le
Above part, the 1th poly is erased by next poly in back-prune
This sub_sequences invd_vp has weaved:1
< < < Tree::dfs_sub_sequences_traverse()
sub_sequences.size()/capacity():1/1
This PRE_LOC has banged:1
< < < Tree::two_per_group()
< < < Tree::sequences generation()
- ( !init_poly_flag ) in Location::le

/ Start to solve Location Location_0
/ Using target_prior2
/ Read(Traverse) Sequences
> > > Tree::dfs_sequences_traverse()

sequence:10
/-----------------------------
( Weaved Prune Tree, current length is 2
( 1  ⋁   0 [1] --  b: 0 --  Location:: Location_0
( 0  ⋁  [0]    --  b: 0 --  Location:: le
For location: Location_0
「 l: 0, vars_num: 4, dual_num: 10 」
> > > Project_by_Kohler(), doing...
< < < Project_by_Kohler(), done!

- Have Collected 1 invariant(s)
- The collect_invariants Time Taken (0.01s) = 0
\-----------------------------
< < < Tree::dfs_sequences_traverse()
- ( !init_poly_flag ) in Location::le

> > > compute_invariants_by_propagation_with_farkas()
- YES! Initial Location:: Location_0
' 1 location [ 0 ] remained in initial_lid

> > > invgen_need_working()
* all_ppg_flag: 1
! invgen is over !
< < < invgen_need_working()
/------------------------------(Propagation to Exit-Location)
= Location le is being Propagated:
= From Location invariant Location_0
  C >= 0
= Through Transition relation Exit_Transition_from_0_index_0: 
  C - G = -1, C - E >= -1, A - C >= 1
= Propagated Location Invariant le
  true
* After intersection 
  C - G = -1, C - E >= -1, A - C >= 1, C >= 0
* Propagated Invariant at le
  C >= 1, -A + C >= 0
\------------------------------(Propagation to Exit-Location)
< < < compute_invariants_by_propagation_with_farkas()
----------------------------- 
| The Locations read in are: 
----------------------------- 

Location: Location_0
# of variables: 4
「 l: 0, vars_num: 4, dual_num: 10 」
Initial Condition: [[ 
| 
├ 1 * i_initvariable_avoid_var_conflict_october  = 0 
├ 1 * i  = 0 
| 
]]
Invariant: [[ 
| 
├ 1 * i  >= 0
| 
]]

Location: le
# of variables: 4
「 l: 5, vars_num: 4, dual_num: 10 」
[ no initial condition set]
Disjunctive Invariant: [[ 
  
1 * i -1 >= 0
-1 * nEncoded  + 1 * i  >= 0
  
]]
[info] Using default compilation options.


[print statement info]
DeclStmt


[print statement info]
DeclStmt


[print statement info]
WhileStmt


[print statement info]
IfStmt


[print statement info]
UnaryOperator
unary operator: DeclRefExpr ++ 

[Print DNF Information]
DNF disjunctive branch 0 and its size is:2
	[DNF Number 0 is:]
	i < nEncoded
	[DNF Number 1 is:]
	i = i + 1
DNF disjunctive clause 0 is printed.
[Print Init_DNF Information]
Init_DNF disjunctive branch 0 and its size is:0
Init_DNF disjunctive clause 0 is printed.

[Print Init Variables Information]
Vars Count 0 and its member size is: 2
	[Variable Number 0 is:]
	 Variable Name is:i
	 Variable Value is:0
	 Variable InLoop is: 0
	 Variable Type is: int
	[Variable Number 1 is:]
	 Variable Name is:equalSignNum
	 Variable Value is:0
	 Variable InLoop is: 0
	 Variable Type is: int


[Print Variables Information]
Vars Count 0 and its member size is: 0

[check_guard info] The Expr i_initvariable_avoid_var_conflict_october = 0 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr i = i_initvariable_avoid_var_conflict_october is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr i < nEncoded is guard

[check_guard info] The Expr i = i + 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr i < nEncoded is guard

[check_guard info] The Expr i < nEncoded is guard

[check_guard info] The Expr i = i + 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr i < nEncoded is guard

[check_guard info] The Expr i = i + 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr i < nEncoded is guard

[check_guard info] The Expr i = i + 1 is not guard

[check_guard info] The Expr is type of =

[check_guard info] The Expr i >= nEncoded is guard


[print statement info]
ReturnStmt
