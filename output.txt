[info] Using default compilation options.

[print statement info]
DeclStmt
	[VarType] int
	[name]__static_local

[print statement info]
BinaryOperator
binary operator: DeclRefExpr = IntegerLiteral 
[print statement info]
ReturnStmt

[INFO DealWithStmt:510] record function: before_loop of which dnf is :

[Print SelfDefined DNF Information]
DNF disjunctive branch 0 and its size is:1
	[DNF Number 0 is:]
	1 * before_loop_RetVal == 0
DNF disjunctive clause 0 is printed.

[print statement info]
DeclStmt
	[VarType] int
	[name]__static_local

[print statement info]
BinaryOperator
binary operator: DeclRefExpr = IntegerLiteral 
[print statement info]
ReturnStmt

[INFO DealWithStmt:510] record function: after_loop of which dnf is :

[Print SelfDefined DNF Information]
DNF disjunctive branch 0 and its size is:1
	[DNF Number 0 is:]
	1 * after_loop_RetVal == 0
DNF disjunctive clause 0 is printed.

[print statement info]
DeclStmt
	[VarType] int
	[name]__static_local

[print statement info]
BinaryOperator
binary operator: DeclRefExpr = IntegerLiteral 
[print statement info]
BinaryOperator
binary operator: DeclRefExpr = ImplicitCastExpr 
[print statement info]
ReturnStmt

[INFO DealWithStmt:510] record function: bar of which dnf is :

[Print SelfDefined DNF Information]
DNF disjunctive branch 0 and its size is:2
	[DNF Number 0 is:]
	1 * i - 1 * j == 0
	[DNF Number 1 is:]
	1 * bar_RetVal == 0
DNF disjunctive clause 0 is printed.

[print statement info]
ParenExpr
paren expression: BinaryOperator 
[print statement info]
ForStmt

[print statement info]
DeclStmt
	[VarType] int
	[name]i

[INFO DealWithStmt:342] After collect initial DNF information: 

[Print DNF Information]
DNF disjunctive branch 0 and its size is:1
	[DNF Number 0 is:]
	i_initvariable_avoid_conflict = 0
DNF disjunctive clause 0 is printed.

[Print inequality_DNF Information]
inequality_DNF disjunctive branch 0 and its size is:0
inequality_DNF disjunctive clause 0 is printed.


[Print DNF Information]
DNF disjunctive branch 0 and its size is:0
DNF disjunctive clause 0 is printed.

[Print inequality_DNF Information]
inequality_DNF disjunctive branch 0 and its size is:1
	[inequality_DNF Number 0 is:]
	i < 10
inequality_DNF disjunctive clause 0 is printed.

[print statement info]
CallExpr

[INFO DealWithCallExpr:245] Function Name:bar
[INFO DealWithCallExpr:256] After Merge Function Call

[Print DNF Information]
DNF disjunctive branch 0 and its size is:0
DNF disjunctive clause 0 is printed.

[Print inequality_DNF Information]
inequality_DNF disjunctive branch 0 and its size is:3
	[inequality_DNF Number 0 is:]
	i < 10
	[inequality_DNF Number 1 is:]
	1 * i - 1 * j == 0
	[inequality_DNF Number 2 is:]
	1 * bar_RetVal == 0
inequality_DNF disjunctive clause 0 is printed.

[INFO DealWithStmt:429] bar_RetVal
[print statement info]
UnaryOperator
unary operator: DeclRefExpr ++ 
[INFO Out_Loop:1557] Collect Loop Transition Relation

[Print DNF Information]
DNF disjunctive branch 0 and its size is:1
	[DNF Number 0 is:]
	i = i + 1
DNF disjunctive clause 0 is printed.

[Print inequality_DNF Information]
inequality_DNF disjunctive branch 0 and its size is:2
	[inequality_DNF Number 0 is:]
	i < 10
	[inequality_DNF Number 1 is:]
	1 * i - 1 * j == 0
inequality_DNF disjunctive clause 0 is printed.

[INFO Compute_and_Eliminate_Init_Poly:812] i_initvariable_avoid_conflict = 0
[INFO Compute_and_Eliminate_Init_Poly:850] Before Transform init_dnf into polyhedron: 

[Print SelfDefined DNF Information]
DNF disjunctive branch 0 and its size is:3
	[DNF Number 0 is:]
	i = i_initvariable_avoid_conflict
	[DNF Number 1 is:]
	i_initvariable_avoid_conflict = 0
	[DNF Number 2 is:]
	i_initvariable_avoid_conflict < 10
DNF disjunctive clause 0 is printed.

[INFO Elimiate_Impossible_Path:1367] Before Eliminate impossible path

[Print DNF Information]
DNF disjunctive branch 0 and its size is:2
	[DNF Number 0 is:]
	i = i + 1
	[DNF Number 1 is:]
	i_initvariable_avoid_conflict = i_initvariable_avoid_conflict
DNF disjunctive clause 0 is printed.

[Print inequality_DNF Information]
inequality_DNF disjunctive branch 0 and its2

----------------------------- 
| The Locations read in are: 
----------------------------- 

Location: Location_0
# of variables: 4
「 l: 0, vars_num: 4, dual_num: 10 」
Initial Condition: [[ 
| 
├ 1 * i_initvariable_avoid_conflict  = 0 
├ 1 * i  = 0 
| 
]]
Invariant: [[ 
| 
├  True
| 
]]

Location: le
# of variables: 4
「 l: 5, vars_num: 4, dual_num: 10 」
[ no initial condition set]
Invariant: [[ 
| 
├  True
| 
]]
----------------------------- 
| The Transitions read in are: 
----------------------------- 
Transition Relation: Transition_0_0
Pre-Location:Location_0   Post-Location:Location_0
Transition Relation: [[
| 
├ 1 * i_initvariable_avoid_conflict -1 * `i_initvariable_avoid_conflict  = 0 
├ 1 * i -1 * `j  + 1 = 0 
├ 1 * i -1 * `i  + 1 = 0 
├ 1 * i -1 * j  = 0 
├ -1 * i  + 8 >= 0
| 
]]
Guard: [[
| 
├ 1 * i -1 * j  = 0 
├ -1 * i  + 8 >= 0
| 
]]
Update: [[
| 
├ 1 * i -1 * `j  + 1 = 0 
├ 1 * i -1 * `i  + 1 = 0 
| 
]]
Preserved: [[
| 
├  i_initvariable_avoid_conflict
| 
]]

- Transition Relation Transition_0_0 Ends
----------------------------- 
Transition Relation: Exit_Transition_from_0_index_0
Pre-Location:Location_0   Post-Location:le
Transition Relation: [[
| 
├ 1 * i_initvariable_avoid_conflict -1 * `i_initvariable_avoid_conflict  = 0 
├ 1 * `i -10 = 0 
├ 1 * j -9 = 0 
├ 1 * i -9 = 0 
| 
]]
Guard: [[
| 
├ 1 * j -9 = 0 
├ 1 * i -9 = 0 
| 
]]
Update: [[
| 
├ 1 * `i -10 = 0 
| 
]]
Preserved: [[
| 
├  i_initvariable_avoid_conflict
| 
]]

- Transition Relation Exit_Transition_from_0_index_0 Ends
----------------------------- 

- Initialize_before_Parser doing...
/----------------------------- 
| Adjacency Matrix for Location and Transition: 
----------------------------- 
| Input: 2 transitions
----------------------------- 
| [#] is transition_index
| Location_0: [ 0 ]->Location_0;  [ 1 ]->le;  
| le: []->Location_0;  []->le;  
----------------------------- 
| Output: 2 transitions
\----------------------------- 

> > > Location::compute_dual_constraints(), Location: Location_0's Initialization
- Initial-Value is not empty: 
  C = 0, A = 0
< < < Location::compute_dual_constraints(), Location: Location_0's Initialization

> > > Location::compute_dual_constraints(), Location: le's Initialization
- Initial-Value is not empty: 
  true
< < < ( !polyset ) in Location::le

> > > (intra transition) In compute_consecution_constraints(), TransitionRelation : Transition_0_0
Current transition has poly as follows: 
  C - G = 0, A - B = 0, A - E = -1, A - F = -1, -A >= -8
  Compute this transition: 1
  pushing back clump with 1 Polyhedra (in falsepath)...
< < < Intra-Transition::Transition_0_0 prepare to push back clump with 1 Polyhedra

> > > (inter transition) In compute_consecution_01(), TransitionRelation : Exit_Transition_from_0_index_0
Current transition has poly as follows: 
  E = 10, C - G = 0, B = 9, A = 9
  Compute this transition: 0
< < < Inter-Transition::Exit_Transition_from_0_index_0 pushing back clump with 0 Polyhedra...done
> > > Location::Location_0 already has clump with 1 Polyhedra...
> > > Location::Location_0 altogether pushing back clump with 3 Polyhedra...done
> > > Location::le already has clump with 0 Polyhedra...
> > > Location::le altogether pushing back clump with 1 Polyhedra...done

/ Start to solve Location Location_0
/ Using target_prior2
/ Generate Sequences
> > > Tree::sequences generation()
> > > Tree::two_per_group()

From hb:1 To lb:0
> > > Tree::dfs_sub_sequences_traverse()
( Weaved Prune Tree, current length is 2
( 1  ⋁  [0] 1  2  --  b: 0 --  Location_Intra:: Location_0
( 0  ⋁  [0]       --  b: 0 --  Location_Intra:: le
( Weaved Prune Tree, current length is 2
( 1  ⋁   0 [1] 2  --  b: 0 --  Location_Intra:: Location_0
( 0  ⋁  [0]       --  b: 0 --  Location_Intra:: le
Above part, the 1th poly is erased by next poly in back-prune
( Weaved Prune Tree, current length is 2
( 1  ⋁   0  1 [2] --  b: 0 --  Location_Intra:: Location_0
( 0  ⋁  [0]       --  b: 0 --  Location_Intra:: le
This sub_sequences invd_vp has weaved:2
< < < Tree::dfs_sub_sequences_traverse()
sub_sequences.size()/capacity():2/2
This PRE_LOC has banged:1
< < < Tree::two_per_group()
< < < Tree::sequences generation()
- ( !init_poly_flag ) in Location::le

/ Start to solve Location Location_0
/ Using target_prior2
/ Read(Traverse) Sequences
> > > Tree::dfs_sequences_traverse()

sequence:10
/-----------------------------
( Weaved Prune Tree, current length is 2
( 1  ⋁   0 [1] 2  --  b: 0 --  Location:: Location_0
( 0  ⋁  [0]       --  b: 0 --  Location:: le
For location: Location_0
「 l: 0, vars_num: 4, dual_num: 10 」
> > > Project_by_Kohler(), doing...
< < < Project_by_Kohler(), done!

- Have Collected 1 invariant(s)
- The collect_invariants Time Taken (0.01s) = 0
\-----------------------------

sequence:20
/-----------------------------
( Weaved Prune Tree, current length is 2
( 1  ⋁   0  1 [2] --  b: 0 --  Location:: Location_0
( 0  ⋁  [0]       --  b: 0 --  Location:: le
For location: Location_0
「 l: 0, vars_num: 4, dual_num: 10 」
> > > Project_by_Kohler(), doing...
< < < Project_by_Kohler(), done!

- Have Collected 2 invariant(s)
- The collect_invariants Time Taken (0.01s) = 0
\-----------------------------
< < < Tree::dfs_sequences_traverse()
- ( !init_poly_flag ) in Location::le

> > > compute_invariants_by_propagation_with_farkas()
- YES! Initial Location:: Location_0
' 1 location [ 0 ] remained in initial_lid

> > > invgen_need_working()
* all_ppg_flag: 1
! invgen is over !
< < < invgen_need_working()
/------------------------------(Propagation to Exit-Location)
= Location le is being Propagated:
= From Location invariant Location_0
  C = 0, A >= 0, -A >= -9
= Through Transition relation Exit_Transition_from_0_index_0: 
  E = 10, C - G = 0, B = 9, A = 9
= Propagated Location Invariant le
  true
* After intersection 
  G = 0, E = 10, C = 0, B = 9, A = 9
* Propagated Invariant at le
  C = 0, A = 10
\------------------------------(Propagation to Exit-Location)
< < < compute_invariants_by_propagation_with_farkas()
----------------------------- 
| The Locations read in are: 
----------------------------- 

Location: Location_0
# of variables: 4
「 l: 0, vars_num: 4, dual_num: 10 」
Initial Condition: [[ 
| 
├ 1 * i_initvariable_avoid_conflict  = 0 
├ 1 * i  = 0 
| 
]]
Invariant: [[ 
| 
├ 1 * i_initvariable_avoid_conflict  = 0 
├ 1 * i  >= 0
├ -1 * i  + 9 >= 0
| 
]]

Location: le
# of variables: 4
「 l: 5, vars_num: 4, dual_num: 10 」
[ no initial condition set]
Disjunctive Invariant: [[ 
  
1 * i_initvariable_avoid_conflict  = 0 
1 * i -10 = 0 
  
]]
 size is:2
	[inequality_DNF Number 0 is:]
	i < 10
	[inequality_DNF Number 1 is:]
	1 * i - 1 * j == 0
inequality_DNF disjunctive clause 0 is printed.

[INFO Compute_Loop_Invariant:1508] 1

[Print SelfDefined DNF Information]

[INFO deduplication:63] loop_invariant before deduplication

[Print SelfDefined DNF Information]
DNF disjunctive branch 0 and its size is:1
	[DNF Number 0 is:]
	1 * i - 10 == 0
DNF disjunctive clause 0 is printed.
DNF disjunctive branch 1 and its size is:2
	[DNF Number 0 is:]
	1 * i >= 0
	[DNF Number 1 is:]
	-1 * i + 9 >= 0
DNF disjunctive clause 1 is printed.

[INFO deduplication:91] Final ACSL invariant Before Add Remain:

[Print SelfDefined DNF Information]
DNF disjunctive branch 0 and its size is:1
	[DNF Number 0 is:]
	1 * i - 10 == 0
DNF disjunctive clause 0 is printed.
DNF disjunctive branch 1 and its size is:2
	[DNF Number 0 is:]
	1 * i >= 0
	[DNF Number 1 is:]
	-1 * i + 9 >= 0
DNF disjunctive clause 1 is printed.

[INFO DealWithStmt:381] Remained DNF:

[Print SelfDefined DNF Information]

[print statement info]
ParenExpr
paren expression: BinaryOperator 
[print statement info]
ParenExpr
paren expression: BinaryOperator 
[print statement info]
ParenExpr
paren expression: BinaryOperator CalleeFunction:before_loop
CalleeFunction:bar
CalleeFunction:after_loop
